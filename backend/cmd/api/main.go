package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"orthotrack-iot-v3/internal/config"
	"orthotrack-iot-v3/internal/database"
	"orthotrack-iot-v3/internal/handlers"
	"orthotrack-iot-v3/internal/middleware"
	"orthotrack-iot-v3/internal/services"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/redis/go-redis/v9"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	_ "orthotrack-iot-v3/cmd/api/docs" // docs is generated by Swag CLI
)

func main() {
	// Carregar configurações
	cfg := config.Load()
	
	log.Printf("Starting OrtoTrack IoT Platform v3")
	log.Printf("Port: %s", cfg.Port)

	// Conectar ao banco de dados
	db, err := connectDatabase(cfg)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// Conectar ao Redis
	redisClient := connectRedis(cfg)

	// Executar migrações
	if err := database.AutoMigrate(db); err != nil {
		log.Fatalf("Failed to run migrations: %v", err)
	}

	// Seed initial data
	if err := database.SeedData(db); err != nil {
		log.Printf("Warning: Failed to seed data: %v", err)
	}

	// Inicializar serviços
	iotService := services.NewIoTService(db, redisClient, cfg)
	alertService := services.NewAlertService(db, redisClient)
	mqttService := services.NewMQTTService(cfg)
	
	// Create Redis manager for WebSocket server
	redisManager := services.NewRedisManager(cfg.Redis.Host, cfg.Redis.Port, cfg.Redis.Password, cfg.Redis.DB, cfg.Redis.PoolSize, cfg.Redis.MinIdleConns, cfg.Redis.MaxRetries)
	ctx := context.Background()
	if err := redisManager.Connect(ctx); err != nil {
		log.Fatalf("Failed to connect Redis manager: %v", err)
	}
	
	// Create channel authorizer
	channelAuthorizer := services.NewChannelAuthorizer(db)
	wsServer := services.NewWSServer(redisManager, channelAuthorizer)

	// Configurar dependências entre serviços
	iotService.SetAlertService(alertService)
	iotService.SetMQTTService(mqttService)
	mqttService.SetIoTService(iotService)

	// Start WebSocket server
	go wsServer.Run()

	// Conectar ao MQTT
	if err := mqttService.Connect(); err != nil {
		log.Fatalf("Failed to connect to MQTT: %v", err)
	}
	defer mqttService.Disconnect()

	// Configurar Gin
	if cfg.Port == "8080" {
		gin.SetMode(gin.ReleaseMode)
	}

	router := gin.New()
	router.Use(gin.Logger())
	router.Use(gin.Recovery())

	// CORS - Configuração segura
	corsConfig := cors.DefaultConfig()
	// Origens permitidas (ajuste conforme necessário)
	allowedOrigins := os.Getenv("ALLOWED_ORIGINS")
	if allowedOrigins == "" {
		// Default para produção - usar IP do VPS
		corsConfig.AllowOrigins = []string{
			"http://72.60.50.248:3000",
			"http://72.60.50.248:8080",
			"https://dashboard.orthotrack.aacd.org.br",
			"https://admin.orthotrack.aacd.org.br",
		}
	} else {
		// Remover espaços e dividir por vírgula
		origins := strings.Split(allowedOrigins, ",")
		for i, origin := range origins {
			origins[i] = strings.TrimSpace(origin)
		}
		corsConfig.AllowOrigins = origins
	}
	corsConfig.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
	corsConfig.AllowHeaders = []string{
		"Origin", "Content-Length", "Content-Type", "Authorization",
		"X-Device-API-Key", "Accept", "X-Requested-With",
	}
	corsConfig.AllowCredentials = true
	router.Use(cors.New(corsConfig))

	// Rate Limiting - 100 req/sec burst 200
	globalRateLimit := middleware.NewRateLimiter(100, 200)
	router.Use(globalRateLimit.Middleware())
	
	// Per-IP Rate Limiting - 10 req/sec burst 20 
	ipRateLimit := middleware.NewIPRateLimiter(10, 20)
	
	// Middleware de autenticação
	authMiddleware := middleware.NewAuthMiddleware(cfg.JWT.Secret)

	// Inicializar handlers
	authHandler := handlers.NewAuthHandler(db, cfg)
	iotHandler := handlers.NewIoTHandler(iotService, alertService)
	iotHandler.SetWSServer(wsServer)
	adminHandler := handlers.NewAdminHandler(db, iotService, alertService)

	// Swagger documentation
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Rotas públicas - com rate limiting mais restritivo
	public := router.Group("/api/v1")
	public.Use(ipRateLimit.Middleware()) // Rate limiting por IP
	{
		public.POST("/auth/login", authHandler.Login)
		public.GET("/health", healthCheck)
	}

	// Rotas de dispositivos (autenticação de dispositivo)
	deviceRoutes := router.Group("/api/v1/devices")
	deviceRoutes.Use(middleware.DeviceAuthWithDB(db))
	{
		deviceRoutes.POST("/telemetry", iotHandler.ReceiveTelemetry)
		deviceRoutes.POST("/status", iotHandler.ReceiveDeviceStatus)
		deviceRoutes.POST("/alerts", iotHandler.ReceiveDeviceAlert)
		deviceRoutes.POST("/commands/response", iotHandler.ReceiveCommandResponse)
	}

	// Rotas protegidas (usuários)
	protected := router.Group("/api/v1")
	protected.Use(authMiddleware.Authenticate())
	{
		// Pacientes
		protected.GET("/patients", adminHandler.GetPatients)
		protected.POST("/patients", adminHandler.CreatePatient)
		protected.GET("/patients/:id", adminHandler.GetPatient)
		protected.PUT("/patients/:id", adminHandler.UpdatePatient)
		protected.DELETE("/patients/:id", adminHandler.DeletePatient)

		// Dispositivos (Braces)
		protected.GET("/braces", adminHandler.GetOrteses)
		protected.POST("/braces", adminHandler.CreateOrtese)
		protected.GET("/braces/:id", adminHandler.GetOrtese)
		protected.PUT("/braces/:id", adminHandler.UpdateOrtese)
		protected.DELETE("/braces/:id", adminHandler.DeleteOrtese)

		// Comandos para dispositivos
		protected.POST("/braces/:id/commands", iotHandler.SendCommand)
		protected.GET("/braces/:id/commands", iotHandler.GetCommands)

		// Alertas
		protected.GET("/alerts", iotHandler.GetAlerts)
		protected.PUT("/alerts/:id/resolve", iotHandler.ResolveAlert)
		protected.GET("/alerts/statistics", iotHandler.GetAlertStatistics)

		// Relatórios e analytics
		protected.GET("/reports/compliance", adminHandler.GetComplianceReport)
		protected.GET("/reports/usage", adminHandler.GetUsageReport)
		protected.GET("/reports/export", adminHandler.ExportData)

		// Dashboard
		protected.GET("/dashboard/overview", adminHandler.GetDashboardOverview)
		protected.GET("/dashboard/realtime", adminHandler.GetRealtimeData)
		
		// WebSocket Metrics
		protected.GET("/websocket/metrics", func(c *gin.Context) {
			wsServer.ServeMetrics(c.Writer, c.Request)
		})
	}

	// Rotas WebSocket para tempo real
	router.GET("/ws", iotHandler.HandleWebSocket)

	// Iniciar servidor HTTP - escutar em todas as interfaces (0.0.0.0)
	server := &http.Server{
		Addr:           "0.0.0.0:" + cfg.Port,
		Handler:        router,
		ReadTimeout:    15 * time.Second,
		WriteTimeout:   15 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	// Canal para capturar sinais do sistema
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Iniciar servidor em goroutine
	go func() {
		log.Printf("Server starting on port %s", cfg.Port)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// Aguardar sinal de parada
	<-quit
	log.Printf("Shutting down server...")

	// Graceful shutdown
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Printf("Server forced to shutdown: %v", err)
	}

	log.Printf("Server stopped")
}

func connectDatabase(cfg *config.Config) (*gorm.DB, error) {
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=UTC",
		cfg.Database.Host,
		cfg.Database.User,
		cfg.Database.Password,
		cfg.Database.Name,
		cfg.Database.Port,
		cfg.Database.SSLMode,
	)

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}

	// Configurar pool de conexões
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to configure database: %v", err)
	}

	sqlDB.SetMaxIdleConns(10)
	sqlDB.SetMaxOpenConns(100)
	sqlDB.SetConnMaxLifetime(time.Hour)

	log.Printf("Connected to database: %s", cfg.Database.Name)
	return db, nil
}

func connectRedis(cfg *config.Config) *redis.Client {
	client := redis.NewClient(&redis.Options{
		Addr:         fmt.Sprintf("%s:%s", cfg.Redis.Host, cfg.Redis.Port),
		Password:     cfg.Redis.Password,
		DB:           cfg.Redis.DB,
		PoolSize:     cfg.Redis.PoolSize,
		MinIdleConns: cfg.Redis.MinIdleConns,
		MaxRetries:   cfg.Redis.MaxRetries,
	})

	// Retry connection with exponential backoff
	maxRetries := 10
	baseDelay := 1 * time.Second
	
	for i := 0; i < maxRetries; i++ {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		err := client.Ping(ctx).Err()
		cancel()
		
		if err == nil {
			log.Printf("✅ Connected to Redis: %s:%s (attempt %d/%d)", cfg.Redis.Host, cfg.Redis.Port, i+1, maxRetries)
			return client
		}
		
		if i == maxRetries-1 {
			log.Fatalf("❌ Failed to connect to Redis after %d attempts: %v", maxRetries, err)
		}
		
		delay := baseDelay * time.Duration(1<<uint(i)) // Exponential backoff
		if delay > 30*time.Second {
			delay = 30 * time.Second // Cap at 30 seconds
		}
		
		log.Printf("⚠️ Redis connection attempt %d/%d failed: %v. Retrying in %v...", i+1, maxRetries, err, delay)
		time.Sleep(delay)
	}
	
	return client
}

func healthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":    "healthy",
		"timestamp": time.Now(),
		"version":   "3.0.0",
	})
}