name: üöÄ Deploy to Production VPS

on:
  push:
    branches: [ main, production ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  VPS_HOST: 72.60.50.248
  VPS_USER: root
  DEPLOY_PATH: /opt/orthotrack
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 3s
          --health-timeout 5s
          --health-retries 30
          --health-start-period 60s
          --memory=2g
          --memory-swap=2g
          --sysctl net.core.somaxconn=65535
          --ulimit nofile=65535:65535
        env:
          REDIS_MAXMEMORY: 1gb
          REDIS_MAXMEMORY_POLICY: allkeys-lru
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure system for Redis
        run: |
          echo "üîß Configuring system for Redis..."
          
          # Enable memory overcommit
          sudo sysctl -w vm.overcommit_memory=1
          echo "‚úÖ Memory overcommit enabled: $(cat /proc/sys/vm/overcommit_memory)"
          
          # Increase network settings for Redis
          sudo sysctl -w net.core.somaxconn=65535
          echo "‚úÖ Network somaxconn set: $(cat /proc/sys/net/core/somaxconn)"
          
          # Disable transparent huge pages (can cause Redis issues)
          echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled > /dev/null || echo "Could not disable THP"
          
          # Show current system limits
          echo "üìä Current system limits:"
          ulimit -n
          free -h
          df -h

      - name: Install Redis CLI tools
        run: sudo apt-get update && sudo apt-get install -y redis-tools

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Wait for Redis to be healthy
        run: |
          echo "Waiting for Redis to be ready..."
          timeout=120
          counter=0
          
          while ! redis-cli -h localhost -p 6379 ping > /dev/null 2>&1; do
            if [ $counter -ge $timeout ]; then
              echo "‚ùå Redis did not become ready in $timeout seconds"
              # Show Redis logs for debugging
              docker logs $(docker ps -q --filter "ancestor=redis:7-alpine") || echo "Could not get Redis logs"
              exit 1
            fi
            echo "‚è≥ Waiting for Redis... ($counter/$timeout)"
            sleep 2
            counter=$((counter + 2))
          done
          
          echo "‚úÖ Redis is ready!"
          
          # Extended verification with basic operations
          redis-cli -h localhost -p 6379 ping
          redis-cli -h localhost -p 6379 info server
          redis-cli -h localhost -p 6379 config get save
          redis-cli -h localhost -p 6379 set test_key "test_value"
          redis-cli -h localhost -p 6379 get test_key
          redis-cli -h localhost -p 6379 del test_key
          
          # Test connection pooling
          for i in {1..5}; do
            redis-cli -h localhost -p 6379 ping > /dev/null &
          done
          wait
          
          echo "‚úÖ Redis health check completed successfully!"

      - name: Verify Redis Pub/Sub readiness
        run: |
          echo "Testing Redis Pub/Sub functionality..."
          
          # Test multiple pub/sub scenarios
          for test_num in {1..3}; do
            echo "Running Pub/Sub test $test_num/3..."
            
            # Simple pub/sub test
            redis-cli -h localhost -p 6379 subscribe test_channel_$test_num > /tmp/redis_sub_$test_num.log 2>&1 &
            SUB_PID=$!
            sleep 3
            
            # Publish test message
            redis-cli -h localhost -p 6379 publish test_channel_$test_num "test_message_$test_num" > /dev/null
            sleep 2
            
            # Stop subscriber
            kill $SUB_PID 2>/dev/null || true
            wait $SUB_PID 2>/dev/null || true
            
            # Check if message was received
            if grep -q "test_message_$test_num" /tmp/redis_sub_$test_num.log; then
              echo "‚úÖ Redis Pub/Sub test $test_num passed!"
            else
              echo "‚ö†Ô∏è Redis Pub/Sub test $test_num had issues:"
              cat /tmp/redis_sub_$test_num.log
            fi
          done
          
          # Test Redis connection under load
          echo "Testing Redis under concurrent connections..."
          for i in {1..10}; do
            redis-cli -h localhost -p 6379 ping > /dev/null &
          done
          wait
          
          echo "‚úÖ Redis is fully ready for tests"

      - name: Run comprehensive Redis diagnostics
        run: |
          echo "üîç Running comprehensive Redis diagnostics..."
          ./scripts/redis-diagnostics.sh

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci --legacy-peer-deps

      - name: Run frontend tests
        run: |
          cd frontend
          npm test

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Run backend tests with retry logic
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: ""
          REDIS_DB: 0
          CGO_ENABLED: 0
        run: |
          cd backend
          go mod download
          echo "üß™ Running backend tests with Redis at $REDIS_HOST:$REDIS_PORT"
          
          # Pre-test Redis verification and warm-up
          echo "üîç Pre-test Redis verification and warm-up..."
          redis-cli -h $REDIS_HOST -p $REDIS_PORT ping
          redis-cli -h $REDIS_HOST -p $REDIS_PORT info memory
          redis-cli -h $REDIS_HOST -p $REDIS_PORT config get maxmemory-policy
          
          # Warm up Redis with some operations
          echo "üî• Warming up Redis..."
          for i in {1..10}; do
            redis-cli -h $REDIS_HOST -p $REDIS_PORT set warmup_key_$i "warmup_value_$i" > /dev/null
            redis-cli -h $REDIS_HOST -p $REDIS_PORT get warmup_key_$i > /dev/null
            redis-cli -h $REDIS_HOST -p $REDIS_PORT del warmup_key_$i > /dev/null
          done
          
          # Test pub/sub functionality that tests rely on
          echo "üîç Testing Pub/Sub functionality for tests..."
          redis-cli -h $REDIS_HOST -p $REDIS_PORT subscribe __test_channel__ > /tmp/test_sub.log 2>&1 &
          TEST_SUB_PID=$!
          sleep 2
          redis-cli -h $REDIS_HOST -p $REDIS_PORT publish __test_channel__ "test_ready" > /dev/null
          sleep 1
          kill $TEST_SUB_PID 2>/dev/null || true
          wait $TEST_SUB_PID 2>/dev/null || true
          
          if grep -q "test_ready" /tmp/test_sub.log; then
            echo "‚úÖ Redis Pub/Sub is working for tests"
          else
            echo "‚ö†Ô∏è Redis Pub/Sub test had issues:"
            cat /tmp/test_sub.log
          fi
          
          # Run tests with enhanced retry logic
          for attempt in 1 2 3 4 5; do
            echo "üß™ Test attempt $attempt/5..."
            
            # Add progressive delay between retries
            if [ $attempt -gt 1 ]; then
              delay=$((attempt * 10))
              echo "‚è≥ Waiting $delay seconds before retry..."
              sleep $delay
              
              # Verify Redis is still responsive and reset any state
              echo "üîç Verifying Redis state before retry..."
              redis-cli -h $REDIS_HOST -p $REDIS_PORT ping
              redis-cli -h $REDIS_HOST -p $REDIS_PORT flushdb > /dev/null
              redis-cli -h $REDIS_HOST -p $REDIS_PORT info clients
              
              # Re-warm Redis
              for i in {1..5}; do
                redis-cli -h $REDIS_HOST -p $REDIS_PORT set retry_warmup_$i "value_$i" > /dev/null
                redis-cli -h $REDIS_HOST -p $REDIS_PORT del retry_warmup_$i > /dev/null
              done
            fi

            echo "üöÄ Starting Go tests (attempt $attempt)..."
            if timeout 20m go test -v -timeout 18m ./...; then
              echo "‚úÖ Tests passed on attempt $attempt"
              exit 0
            else
              test_exit_code=$?
              echo "‚ùå Tests failed on attempt $attempt (exit code: $test_exit_code)"
              
              if [ $attempt -eq 5 ]; then
                echo "üí• Tests failed after 5 attempts"
                echo "üîç Final Redis diagnostics:"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT ping || echo "Redis ping failed"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT info server || echo "Redis info failed"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT info clients || echo "Redis clients info failed"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT info memory || echo "Redis memory info failed"
                
                # Show recent Redis logs
                echo "üîç Recent Redis container logs:"
                docker logs --tail 50 $(docker ps -q --filter "ancestor=redis:7-alpine") || echo "Could not get Redis logs"
                
                exit 1
              fi
              echo "üîÑ Will retry test attempt $((attempt + 1))..."
            fi
          done

  build:
    name: üèóÔ∏è Build Images
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKER_USERNAME }}/orthotrack-backend
            ${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: alexabreup/orthotrack-backend:${{ github.sha }},alexabreup/orthotrack-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: alexabreup/orthotrack-frontend:${{ github.sha }},alexabreup/orthotrack-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            VITE_API_URL=https://api.orthotrack.alexptech.com
            VITE_WS_URL=wss://api.orthotrack.alexptech.com/ws

  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production' || startsWith(github.ref, 'refs/tags/v')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"

      - name: Copy deployment files
        run: |
          # Copy docker-compose and configuration files
          scp docker-compose.prod.yml ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          scp nginx.conf ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          scp mosquitto.conf ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
          # Copy scripts
          scp -r scripts/ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
          # Copy monitoring configuration
          scp -r monitoring/ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/

      - name: Create environment file
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "cat > ${{ env.DEPLOY_PATH }}/backend/.env.production << 'EOF'
          # Database
          DB_HOST=orthotrack-postgres
          DB_PORT=5432
          DB_NAME=orthotrack_prod
          DB_USER=orthotrack
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_SSL_MODE=require
          
          # Redis
          REDIS_HOST=orthotrack-redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_DB=0
          REDIS_POOL_SIZE=20
          REDIS_MIN_IDLE_CONNS=10
          REDIS_MAX_RETRIES=5
          
          # MQTT
          MQTT_HOST=orthotrack-mqtt
          MQTT_PORT=1883
          MQTT_BROKER_URL=tcp://orthotrack-mqtt:1883
          MQTT_USERNAME=orthotrack
          MQTT_PASSWORD=${{ secrets.MQTT_PASSWORD }}
          MQTT_CLIENT_ID=orthotrack-backend-prod
          
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRE_HOURS=24
          
          # Server
          PORT=8080
          GIN_MODE=release
          
          # CORS
          ALLOWED_ORIGINS=https://orthotrack.alexptech.com,https://www.orthotrack.alexptech.com,https://api.orthotrack.alexptech.com,http://72.60.50.248:3000,http://72.60.50.248:8080
          
          # Alertas
          IOT_ALERT_BATTERY_LOW=15
          IOT_ALERT_TEMP_HIGH=45.0
          IOT_ALERT_TEMP_LOW=5.0
          EOF"

      - name: Update docker-compose with new image tags
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            sed -i 's|image: alexabreup/orthotrack-backend:latest|image: alexabreup/orthotrack-backend:${{ github.sha }}|g' ${{ env.DOCKER_COMPOSE_FILE }}
            sed -i 's|image: alexabreup/orthotrack-frontend:latest|image: alexabreup/orthotrack-frontend:${{ github.sha }}|g' ${{ env.DOCKER_COMPOSE_FILE }}
          "

      - name: Deploy application
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            
            # Create backup before deployment
            if [ -f '${{ env.DOCKER_COMPOSE_FILE }}' ]; then
              echo 'üì¶ Creating backup before deployment...'
              ./scripts/backup.sh || echo 'Backup script not found, continuing...'
            fi
            
            # Pull latest images
            echo 'üì• Pulling latest Docker images...'
            docker pull alexabreup/orthotrack-backend:${{ github.sha }}
            docker pull alexabreup/orthotrack-frontend:${{ github.sha }}
            
            # Deploy with zero downtime
            echo 'üöÄ Deploying application...'
            docker-compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d --remove-orphans
            
            # Wait for services to be ready
            echo '‚è≥ Waiting for services to be ready...'
            sleep 30
            
            # Health check
            echo 'üè• Running health checks...'
            ./scripts/health-check.sh || echo 'Health check script not found'
            
            # Clean up old images
            echo 'üßπ Cleaning up old Docker images...'
            docker image prune -f
            
            echo '‚úÖ Deployment completed successfully!'
          "

      - name: Verify deployment
        run: |
          # Wait a bit more for services to fully start
          sleep 60
          
          # Test endpoints
          echo "Testing frontend..."
          curl -f -s -o /dev/null https://orthotrack.alexptech.com/health || echo "Frontend health check failed"
          
          echo "Testing API..."
          curl -f -s -o /dev/null https://api.orthotrack.alexptech.com/health || echo "API health check failed"
          
          echo "Deployment verification completed"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            STATUS="‚úÖ SUCCESS"
            COLOR="good"
          else
            STATUS="‚ùå FAILED"
            COLOR="danger"
          fi
          
          # Send notification (webhook example)
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"üöÄ OrthoTrack Deployment $STATUS\",
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},
                  {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                  {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                  {\"title\": \"Author\", \"value\": \"${{ github.actor }}\", \"short\": true}
                ]
              }]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Notification webhook not configured"

  rollback:
    name: üîÑ Rollback (Manual)
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    environment: production
    steps:
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback to previous version
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            
            echo 'üîÑ Starting rollback process...'
            
            # Get the previous successful deployment
            PREVIOUS_TAG=\$(docker images --format 'table {{.Repository}}:{{.Tag}}' | grep orthotrack-backend | grep -v latest | head -2 | tail -1 | cut -d':' -f2)
            
            if [ -n \"\$PREVIOUS_TAG\" ]; then
              echo \"Rolling back to tag: \$PREVIOUS_TAG\"
              
              # Update docker-compose with previous tag
              sed -i \"s|${{ secrets.DOCKER_USERNAME }}/orthotrack-backend:.*|${{ secrets.DOCKER_USERNAME }}/orthotrack-backend:\$PREVIOUS_TAG|g\" ${{ env.DOCKER_COMPOSE_FILE }}
              sed -i \"s|${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend:.*|${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend:\$PREVIOUS_TAG|g\" ${{ env.DOCKER_COMPOSE_FILE }}
              
              # Deploy previous version
              docker-compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d --remove-orphans
              
              echo '‚úÖ Rollback completed successfully!'
            else
              echo '‚ùå No previous version found for rollback'
              exit 1
            fi
          "