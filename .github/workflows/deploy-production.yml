name: üöÄ Deploy to Production VPS

on:
  push:
    branches: [ main, production ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  VPS_HOST: 72.60.50.248
  VPS_USER: root
  DEPLOY_PATH: /opt/orthotrack
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 10s
          --health-retries 20
          --health-start-period 40s
          --memory=1g
          --memory-swap=1g
          --sysctl net.core.somaxconn=1024
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Enable memory overcommit for Redis
        run: sudo sysctl -w vm.overcommit_memory=1

      - name: Install Redis CLI tools
        run: sudo apt-get update && sudo apt-get install -y redis-tools

      - name: Wait for Redis to be healthy
        run: |
          echo "Waiting for Redis to be ready..."
          timeout=60
          counter=0
          
          while ! redis-cli -h localhost -p 6379 ping > /dev/null 2>&1; do
            if [ $counter -ge $timeout ]; then
              echo "‚ùå Redis did not become ready in $timeout seconds"
              exit 1
            fi
            echo "‚è≥ Waiting for Redis... ($counter/$timeout)"
            sleep 1
            counter=$((counter + 1))
          done
          
          echo "‚úÖ Redis is ready!"
          
          # Final verification with basic operations
          redis-cli -h localhost -p 6379 ping
          redis-cli -h localhost -p 6379 set test_key "test_value"
          redis-cli -h localhost -p 6379 get test_key
          redis-cli -h localhost -p 6379 del test_key
          echo "‚úÖ Redis health check completed successfully!"

      - name: Verify Redis Pub/Sub readiness
        run: |
          echo "Testing Redis Pub/Sub functionality..."
          
          # Simple pub/sub test
          redis-cli -h localhost -p 6379 subscribe test_channel > /tmp/redis_sub.log 2>&1 &
          SUB_PID=$!
          sleep 2
          
          # Publish test message
          redis-cli -h localhost -p 6379 publish test_channel "test_message" > /dev/null
          sleep 1
          
          # Stop subscriber
          kill $SUB_PID 2>/dev/null || true
          
          # Check if message was received
          if grep -q "test_message" /tmp/redis_sub.log; then
            echo "‚úÖ Redis Pub/Sub is working correctly!"
          else
            echo "‚ö†Ô∏è Redis Pub/Sub test had issues, but continuing..."
            cat /tmp/redis_sub.log
          fi
          
          echo "‚úÖ Redis is fully ready for tests"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci --legacy-peer-deps

      - name: Run frontend tests
        run: |
          cd frontend
          npm test

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Run backend tests with retry logic
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: ""
          REDIS_DB: 0
          CGO_ENABLED: 0
        run: |
          cd backend
          go mod download
          echo "üß™ Running backend tests with Redis at $REDIS_HOST:$REDIS_PORT"
          
          # Final Redis verification
          echo "üîç Final Redis verification before tests..."
          redis-cli -h $REDIS_HOST -p $REDIS_PORT ping
          
          # Run tests with retry logic
          for attempt in 1 2 3; do
            echo "üß™ Test attempt $attempt/3..."
            if go test -v -timeout 15m ./...; then
              echo "‚úÖ Tests passed on attempt $attempt"
              break
            else
              if [ $attempt -eq 3 ]; then
                echo "‚ùå Tests failed after 3 attempts"
                exit 1
              fi
              echo "‚ö†Ô∏è Tests failed on attempt $attempt, retrying in 10 seconds..."
              sleep 10
            fi
          done
          TEST_SUB_PID=$!
          sleep 1
          redis-cli -h $REDIS_HOST -p $REDIS_PORT publish __test__ "ready" > /dev/null || true
          sleep 1
          kill $TEST_SUB_PID 2>/dev/null || true
          echo "Redis Pub/Sub pre-test check completed"

          # Run tests with retry logic
          for attempt in 1 2 3; do
            echo "Test attempt $attempt/3..."
            # Add delay between retries to let Redis settle
            if [ $attempt -gt 1 ]; then
              echo "Waiting 15 seconds before retry..."
              sleep 15
              # Verify Redis is still responsive
              redis-cli -h $REDIS_HOST -p $REDIS_PORT ping
            fi

            if go test -v -timeout 15m ./...; then
              echo "Tests passed on attempt $attempt"
              exit 0
            else
              if [ $attempt -eq 3 ]; then
                echo "Tests failed after 3 attempts"
                echo "Final Redis status check:"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT ping || echo "Redis ping failed"
                redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO server || echo "Redis info failed"
                exit 1
              fi
              echo "Tests failed on attempt $attempt, will retry..."
            fi
          done

  build:
    name: üèóÔ∏è Build Images
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKER_USERNAME }}/orthotrack-backend
            ${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: alexabreup/orthotrack-backend:${{ github.sha }},alexabreup/orthotrack-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: alexabreup/orthotrack-frontend:${{ github.sha }},alexabreup/orthotrack-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            VITE_API_URL=https://api.orthotrack.alexptech.com
            VITE_WS_URL=wss://api.orthotrack.alexptech.com/ws

  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production' || startsWith(github.ref, 'refs/tags/v')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"

      - name: Copy deployment files
        run: |
          # Copy docker-compose and configuration files
          scp docker-compose.prod.yml ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          scp nginx.conf ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          scp mosquitto.conf ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
          # Copy scripts
          scp -r scripts/ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
          # Copy monitoring configuration
          scp -r monitoring/ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/

      - name: Create environment file
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "cat > ${{ env.DEPLOY_PATH }}/backend/.env.production << 'EOF'
          # Database
          DB_HOST=orthotrack-postgres
          DB_PORT=5432
          DB_NAME=orthotrack_prod
          DB_USER=orthotrack
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_SSL_MODE=require
          
          # Redis
          REDIS_HOST=orthotrack-redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_DB=0
          REDIS_POOL_SIZE=20
          REDIS_MIN_IDLE_CONNS=10
          REDIS_MAX_RETRIES=5
          
          # MQTT
          MQTT_HOST=orthotrack-mqtt
          MQTT_PORT=1883
          MQTT_BROKER_URL=tcp://orthotrack-mqtt:1883
          MQTT_USERNAME=orthotrack
          MQTT_PASSWORD=${{ secrets.MQTT_PASSWORD }}
          MQTT_CLIENT_ID=orthotrack-backend-prod
          
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRE_HOURS=24
          
          # Server
          PORT=8080
          GIN_MODE=release
          
          # CORS
          ALLOWED_ORIGINS=https://orthotrack.alexptech.com,https://www.orthotrack.alexptech.com,https://api.orthotrack.alexptech.com,http://72.60.50.248:3000,http://72.60.50.248:8080
          
          # Alertas
          IOT_ALERT_BATTERY_LOW=15
          IOT_ALERT_TEMP_HIGH=45.0
          IOT_ALERT_TEMP_LOW=5.0
          EOF"

      - name: Update docker-compose with new image tags
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            sed -i 's|image: alexabreup/orthotrack-backend:latest|image: alexabreup/orthotrack-backend:${{ github.sha }}|g' ${{ env.DOCKER_COMPOSE_FILE }}
            sed -i 's|image: alexabreup/orthotrack-frontend:latest|image: alexabreup/orthotrack-frontend:${{ github.sha }}|g' ${{ env.DOCKER_COMPOSE_FILE }}
          "

      - name: Deploy application
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            
            # Create backup before deployment
            if [ -f '${{ env.DOCKER_COMPOSE_FILE }}' ]; then
              echo 'üì¶ Creating backup before deployment...'
              ./scripts/backup.sh || echo 'Backup script not found, continuing...'
            fi
            
            # Pull latest images
            echo 'üì• Pulling latest Docker images...'
            docker pull alexabreup/orthotrack-backend:${{ github.sha }}
            docker pull alexabreup/orthotrack-frontend:${{ github.sha }}
            
            # Deploy with zero downtime
            echo 'üöÄ Deploying application...'
            docker-compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d --remove-orphans
            
            # Wait for services to be ready
            echo '‚è≥ Waiting for services to be ready...'
            sleep 30
            
            # Health check
            echo 'üè• Running health checks...'
            ./scripts/health-check.sh || echo 'Health check script not found'
            
            # Clean up old images
            echo 'üßπ Cleaning up old Docker images...'
            docker image prune -f
            
            echo '‚úÖ Deployment completed successfully!'
          "

      - name: Verify deployment
        run: |
          # Wait a bit more for services to fully start
          sleep 60
          
          # Test endpoints
          echo "Testing frontend..."
          curl -f -s -o /dev/null https://orthotrack.alexptech.com/health || echo "Frontend health check failed"
          
          echo "Testing API..."
          curl -f -s -o /dev/null https://api.orthotrack.alexptech.com/health || echo "API health check failed"
          
          echo "Deployment verification completed"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            STATUS="‚úÖ SUCCESS"
            COLOR="good"
          else
            STATUS="‚ùå FAILED"
            COLOR="danger"
          fi
          
          # Send notification (webhook example)
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"üöÄ OrthoTrack Deployment $STATUS\",
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},
                  {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                  {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                  {\"title\": \"Author\", \"value\": \"${{ github.actor }}\", \"short\": true}
                ]
              }]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Notification webhook not configured"

  rollback:
    name: üîÑ Rollback (Manual)
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    environment: production
    steps:
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback to previous version
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
            cd ${{ env.DEPLOY_PATH }}
            
            echo 'üîÑ Starting rollback process...'
            
            # Get the previous successful deployment
            PREVIOUS_TAG=\$(docker images --format 'table {{.Repository}}:{{.Tag}}' | grep orthotrack-backend | grep -v latest | head -2 | tail -1 | cut -d':' -f2)
            
            if [ -n \"\$PREVIOUS_TAG\" ]; then
              echo \"Rolling back to tag: \$PREVIOUS_TAG\"
              
              # Update docker-compose with previous tag
              sed -i \"s|${{ secrets.DOCKER_USERNAME }}/orthotrack-backend:.*|${{ secrets.DOCKER_USERNAME }}/orthotrack-backend:\$PREVIOUS_TAG|g\" ${{ env.DOCKER_COMPOSE_FILE }}
              sed -i \"s|${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend:.*|${{ secrets.DOCKER_USERNAME }}/orthotrack-frontend:\$PREVIOUS_TAG|g\" ${{ env.DOCKER_COMPOSE_FILE }}
              
              # Deploy previous version
              docker-compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d --remove-orphans
              
              echo '‚úÖ Rollback completed successfully!'
            else
              echo '‚ùå No previous version found for rollback'
              exit 1
            fi
          "